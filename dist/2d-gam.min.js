// All rights reseved to game2d
//MIT

 class ResponsiveCanvas{
  constructor({id,width,height}){
    
    if (id == "" ||
      id == undefined ||
      id == null) {
      throw new Error("(2d-gam) id is required and couldnot be null or undefind")
    } else if (typeof(id) !== "string") {
      throw new TypeError("(2d-gam) id must be a string")
    }
    
    this.width = width
    this.height = height
    this.id = id
  }
  create(){
    
    if(this.width <= 1 && this.height <= 1){
    let div = document.getElementById(this.id)
    
    div.innerHTML += `
      <canvas width=${innerWidth * this.width} height=${innerHeight * this.height} id="${this.id}@2d-gam">
      </canvas>
    `

    const canvas = document.getElementById(this.id + "@2d-gam")
    const c = canvas.getContext("2d")
    //context
    return c
    }
  }
}
 class Canvas {
  constructor({ id }) {
    this.id = id

    if (id == "" ||
      id == undefined ||
      id == null) {
      throw new Error("(2d-gam) id is required and couldnot be null or undefind")
    } else if (typeof(id) !== "string") {
      throw new TypeError("(2d-gam) id must be a string")
    }

    return id
  }
  create() {
    document.getElementById(this.id).innerHTML = `
       <canvas id="${this.id}@2d-gam"></canvas>
      `
    const canvas = document.getElementById(this.id + "@2d-gam")
    const c = canvas.getContext("2d")
    //context
    return c
  }
}
 function GreateX(array) {
  let GreateX = 0
  for (let i = 0; i < array.length; i++) {
    if (array[i] > GreateX) {
      GreateX = array[i]
    }
    else {
      continue
    }
  }
  return GreateX
}
 function GreateY(array) {
  let GreateY = 0
  for (let i = 0; i < array.length; i++) {
    if (array[i] > GreateY) {
      GreateY = array[i]
    }
    else {
      continue
    }
  }
  return GreateY
}
 class Triangle {
  constructor({
    length = [40, 50, 30],
    position = {
      x: 140,
      y: 100
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    this.length = length
    this.position = position
    this.velocity = velocity
    this.width = GreateX(this.length)
    this.height = GreateY(this.length)
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
  }

  draw(c, callBackFunction = function() {}) {
    //required value
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }

    //darwing the square
    let triangle = new Path2D()
    c.beginPath()
    triangle.moveTo(this.position.x, this.position.y)
    triangle.lineTo(this.position.x + this.length[0], this.position.y)


    triangle.lineTo(this.position.x + this.length[2], this.position.y - this.length[1])

    triangle.lineTo(this.position.x, this.position.y)

    c.strokeStyle = "black"
    c.fillStyle = "transparent"
    callBackFunction(c)
    c.stroke(triangle)
    c.fill(triangle)
    c.beginPath()

    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = triangle
  }

  update(callbackFunction) {
    callbackFunction({
      pos: this.position,
      vel: this.velocity,
      l: this.length,
      s1: this.length[0],
      s2: this.length[1],
      s3: this.length[2],
      w: this.width,
      h: this.height
    })
  }
}
 class Square {
  constructor({
    height = 100,
    width = 100,
    position = {
      x: 0,
      y: 0
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    this.width = width
    this.height = height
    this.position = position
    this.velocity = velocity
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
    this.create = false
  }

  draw(c, callBackFunction = function() {}) {
    //required value
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }

    //darwing the square
    let square = new Path2D()
    c.beginPath()
    square.rect(this.position.x,this.position.y,this.width,this.height)
    c.fillStyle = "transparent"
    c.strokeStyle = "black"
    callBackFunction(c)
    c.stroke(square)
    c.fill(square)
    c.beginPath()

    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = square
  }

  update(callbackFunction) {
    callbackFunction({ w: this.width, h: this.height, pos: this.position, vel: this.velocity })
  }
}
 class Snowflake {
  constructor({
    length = 30,
    position = {
      x: 140,
      y: 140
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    if(length < 20 || length < 0){
      throw new Error("(2d-gam) the length must be more than 20")
    }
    this.length = length
    this.position = position
    this.velocity = velocity
    this.width = length * 2
    this.height = length * 2
    this.create = false
    this.fillcolor = ""
    this.path = ""
    this.strokecolor = ""
  }

  draw(c, callBackFunction = function() {}) {
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }
    
    let Snowflake = new Path2D()
    c.beginPath()
    Snowflake.moveTo(this.position.x, this.position.y)
    Snowflake.lineTo(this.position.x + this.length, this.position.y)



    Snowflake.moveTo(this.position.x, this.position.y)
    Snowflake.lineTo(this.position.x, this.position.y + this.length)

    Snowflake.moveTo(this.position.x, this.position.y)
    Snowflake.lineTo(this.position.x - this.length, this.position.y)

    Snowflake.moveTo(this.position.x, this.position.y)
    Snowflake.lineTo(this.position.x, this.position.y - this.length)

    Snowflake.moveTo(this.position.x, this.position.y)
    Snowflake.lineTo(this.position.x + this.length - 15, this.position.y + this.length - 15)
    
  
    Snowflake.moveTo(this.position.x, this.position.y)
    c.lineTo(this.position.x + this.length - 15, this.position.y - (this.length - 15))

    Snowflake.moveTo(this.position.x, this.position.y)
    Snowflake.lineTo(this.position.x - (this.length - 15), this.position.y + (this.length - 15))

    Snowflake.moveTo(this.position.x, this.position.y)
    Snowflake.lineTo(this.position.x - (this.length - 15), this.position.y - (this.length - 15))

    c.fillStyle = "transparent"
    c.strokeStyle = "black"
    callBackFunction(c)
    c.fill(Snowflake)
    c.stroke(Snowflake)
    c.beginPath()
    
    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = Snowflake
  }

  update(callBackFunction = function() {}) {
    callBackFunction({
      pos: this.position,
      vel: this.velocity,
      l:this.length,
      w: this.width,
      h: this.height
    })
  }
}
 class Circular{
  constructor(shape){
    this.shape = shape
    this.x = this.shape.position.x
    this.y = this.shape.position.y
    this.radians = 0
  }
  run(speed,radius){
    this.radians += speed
    this.shape.position.x = this.x + Math.cos(this.radians) * radius 
    this.shape.position.y = this.y + Math.sin(this.radians) * radius
    
    return {
      position:{
        x:this.shape.position.x,
        y:this.shape.position.y
      },
      speed,
      radians:this.radians
    }
  }
}
 class Move {
  constructor(shape) {
    this.shape = shape
  }
  
  forward(speed) {
    this.shape.position.x += speed
    return {
      position: {
        x: this.shape.position.x,
        y: this.shape.position.y
      },
      speed: 5
    }
  }
  
  backward(speed) {
    this.shape.position.x -= speed
    return {
      position: {
        x: this.shape.position.x,
        y: this.shape.position.y
      },
      speed: 5
    }
  }
  
  diagonalRightBottom(speed){
    this.shape.position.x += speed
    this.shape.position.y += speed
    return {
      position: {
        x: this.shape.position.x,
        y: this.shape.position.y
      },
      speed
    }
  }
  
  diagonalLeftBottom(speed){
    this.shape.position.x -= speed
    this.shape.position.y += speed
    return {
      position: {
        x: this.shape.position.x,
        y: this.shape.position.y
      },
      speed
    }
  }
  
  diagonalRightTop(speed){
    this.shape.position.x += speed
    this.shape.position.y -= speed
    return {
      position: {
        x: this.shape.position.x,
        y: this.shape.position.y
      },
      speed
    }
  }
  
  diagonalLeftTop(speed){
    this.shape.position.x -= speed
    this.shape.position.y -= speed
    return {
      position: {
        x: this.shape.position.x,
        y: this.shape.position.y
      },
      speed
    }
  }
  
  top(speed){
    this.shape.position.y -= speed
    return {
      position: {
        x: this.shape.position.x,
        y: this.shape.position.y
      },
      speed
    }
  }
  
  bottom(speed) {
    this.shape.position.y += speed
    return {
      position: {
        x: this.shape.position.x,
        y: this.shape.position.y
      },
      speed
    }
  }
}
 class Detect {
  constructor(ctx,shape) {
    this.shape = shape
    this.ctx = ctx
  }
  on(type, callBackFunction = function() {}) {
    if (type == "touchTheScreenTop") {
      if (this.shape.position.y - this.shape.height <= 0) {
        callBackFunction()
      }
    }
    if (type == "touchTheScreenBottom") {
      if (this.shape.position.y + this.shape.height - this.shape.velocity.y >= this.ctx.canvas.height) {
        callBackFunction()
      }
    }

    if (type == "touchTheScreenRight") {
      if (this.shape.position.x + this.shape.width + this.shape.velocity.x >= this.ctx.canvas.width) {
        callBackFunction()
      }
    }
    
    if (type == "touchTheScreenLeft") {
      if (this.shape.position.x - this.shape.width <= 0) {
        callBackFunction()
      }
    }
    
  }
}
 const CustomizedEvents = []
 function addTouchOffsets(event) {
  var touch = event.touches[0] || event.changedTouches[0];
  var realTarget = document.elementFromPoint(touch.clientX, touch.clientY);
  event.offsetX = touch.clientX - realTarget.getBoundingClientRect().x;
  event.offsetY = touch.clientY - realTarget.getBoundingClientRect().y
  return event;
}
 class Event {
  constructor(
    shape,
    ctx
  ) {
    if (shape == "" ||
      shape == undefined ||
      shape == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(shape) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a shape class")
    }
    this.shape = shape
    this.ctx = ctx
  }

  on(event, callBackFunction = function() {}) {
    if (event == "create") {
      let Interval = setInterval(() => {
        if (this.ctx.isPointInPath(this.shape.path, this.shape.position.x, this.shape.position.y)) {
          let e = {
            isTrusted: true,
            eventType: "create",
            date: `${new Date().getHours()}:${new Date().getMinutes()}:${new Date().getSeconds()}:${new Date().getMilliseconds()}`,
            positionX: this.shape.position.x,
            positionY: this.shape.position.y,
            shape: this.shape,
          }
          try {
            callBackFunction(e)
            clearInterval(Interval)
          } catch (e) {
            clearInterval(Interval)
            throw new Error(`(2d-gam) an Event error is occaired ${e}`)
          }
        }
      }, 1)
    }
    if (event == "move") {
      let positions = []
      let currentPositionX = this.shape.position.x
      let currentPositionY = this.shape.position.y
      positions.push({
        x: currentPositionX,
        y: currentPositionY,
        date: `${new Date().getHours()}:${new Date().getMinutes()}:${new Date().getSeconds()}:${new Date().getMilliseconds()}`
      })
      let Interval1 = setInterval(() => {
        if (this.shape.position.x !== currentPositionX || this.shape.position.y !== currentPositionY) {
          positions.push({
            x: this.shape.position.x,
            y: this.shape.position.y,
            date: `${new Date().getHours()}:${new Date().getMinutes()}:${new Date().getSeconds()}:${new Date().getMilliseconds()}`
          })
          let e = {
            isTrusted: true,
            eventType: event,
            prevPosition: {
              x: currentPositionX,
              y: currentPositionY
            },
            newPosition: {
              x: this.shape.position.x,
              y: this.shape.position.y
            },
            getDiffrence: function() {
              let diff = {
                x: this.newPosition.x - this.prevPosition.x,
                y: this.newPosition.y - this.prevPosition.y
              }
              return diff
            },
            positions,
            shape: this.shape
          }
          try {
            callBackFunction(e)
            currentPositionX = this.shape.position.x
            currentPositionY = this.shape.position.y
          } catch (e) {
            clearInterval(Interval1)
            throw new Error(`(2d-gam) a failure is occaired ${e}`)
          }
        }
      }, 1)
    }
    if (event == "click" || event == "dblclick" || event == "mousemove" || event == "mouseenter" || event == "mouseup"  || event == "mousedown") {

      this.ctx.canvas.addEventListener(event, (event) => {
        const isPointInPath = this.ctx.isPointInPath(this.shape.path, event.offsetX, event.offsetY)
        if (isPointInPath) {
          let e = event
          callBackFunction(e)
        }
      })
    }
    if (event == "touchstart" || event == "touchend" || event == "touchmove") {
      this.ctx.canvas.addEventListener(event,(event) => {
        const isPointInPath = this.ctx.isPointInPath(this.shape.path,addTouchOffsets(event).offsetX,addTouchOffsets(event).offsetY)
        
        if(isPointInPath){
          let e = event
          callBackFunction(e)
        }
      })
    }
    if (event == "grow") {
      let width = this.shape.width
      let height = this.shape.height
      let Interval3 = setInterval(() => {
        if (this.shape.width > width || this.shape.height > height) {
          let e = {
            isTrusted: true,
            prevWidth: width,
            prevHeight: height,
            newWidth: this.shape.width,
            newHeight: this.shape.height,
            date: `${new Date().getHours()}:${new Date().getMinutes()}:${new Date().getSeconds()}:${new Date().getMilliseconds()}`,
            getDiffrence: function() {
              let diff = {
                width: this.newWidth - this.prevWidth,
                height: this.newHeight - this.prevHeight
              }

              return diff
            },
            shape: this.shape
          }
          width = e.newWidth
          height = e.newHeight
          try {
            callBackFunction(e)
          } catch (e) {
            clearInterval(Interval3)
            throw new Error(`(2d-gam) a failure is occaired ${e}`)
          }
        }
      }, 1)
    }
    if (event == "shrink") {
      let width = this.shape.width
      let height = this.shape.height
      let Interval3 = setInterval(() => {
        if (this.shape.width < width || this.shape.height < height) {
          let e = {
            isTrusted: true,
            prevWidth: width,
            prevHeight: height,
            newWidth: this.shape.width,
            newHeight: this.shape.height,
            date: `${new Date().getHours()}:${new Date().getMinutes()}:${new Date().getSeconds()}:${new Date().getMilliseconds()}`,
            getDiffrence: function() {
              let diff = {
                width: this.prevWidth - this.newWidth,
                height: this.prevHeight - this.newHeight
              }

              return diff
            },
            shape: this.shape
          }
          width = e.newWidth
          height = e.newHeight
          try {
            callBackFunction(e)
          } catch (e) {
            clearInterval(Interval3)
            throw new Error(`(2d-gam) a failure is occaired ${e}`)
          }
        }
      }, 1)
    }

    let therIsOne = false
    for (let i = 0; i < CustomizedEvents.length; i++) {
      if (CustomizedEvents[i].name == event) {
        let therIsOne = true
        let IntervalC = setInterval(() => {
          if (CustomizedEvents[i].run()) {
            let e = {
              isTrusted: true,
              eventType: event,
              customizeEvent: true,
              date: `${new Date().getHours()}:${new Date().getMinutes()}:${new Date().getSeconds()}:${new Date().getMilliseconds()}`
            }
            try {
              callBackFunction(e)
              if (CustomizedEvents[i].stopOnRun) {
                clearInterval(IntervalC)
              }
            } catch (e) {
              clearInterval(IntervalC)
              throw new Error("(2d-gam) a failure is occaired " + e)
            }
          }
        }, 1)
      }
    }
  }

  customEvent(eventName, run = function() {}, stopOnRun = false) {
    CustomizedEvents.push({
      name: eventName,
      run,
      stopOnRun,
    })
  }
}
 class Text {
  constructor({
    text = "Hello World",
    position = {
      x: 100,
      y: 100
    },
    velocity = {
      x: 0,
      y: 0
    },
    maxWidth = 0
  }) {
    this.position = position
    this.velocity = velocity
    this.maxWidth = maxWidth
    this.text = text
  }
  write(c, callBackFunction = function() {}) {
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }


    c.beginPath()
    c.fillStyle = "black"
    c.strokeStyle = "transparent"
    callBackFunction(c,this.text)
    c.fillText(this.text, this.position.x, this.position.y)
    c.beginPath()
  }
  
}
 class Grid {
  constructor(
    ctx,
    distance = 25,
    type = "fullGrid",
    opt = {
      width: ctx.canvas.width,
      height: ctx.canvas.height
    }
  ) {
    //required values
    if (ctx == "" ||
      ctx == undefined ||
      ctx == null) {
      throw new Error("(2d-gam) ctx is required")
    } else if (typeof(ctx) !== "object") {
      throw new TypeError("(2d-gam) ctx value must be an object")
    }
    if(distance < 25){
      throw new Error("(2d-gam) distance cannot be lower than 25")
    }
    this.opt = opt
    this.type = type
    this.width = this.opt.width
    this.height = this.opt.height
    this.ctx = ctx
    this.distance = distance
  }

  run(id, callBackFunction = function() {}) {
    //required values

    if (id == "" ||
      id == undefined ||
      id == null) {
      throw new Error("(2d-gam) id is required")
    } else if (typeof(id) !== "string") {
      throw new TypeError("(2d-gam) id value must be a string")
    }

    var canvas = document.getElementById(id);
    let w = this.width
    let h = this.height
    this.ctx.canvas.width = w;
    this.ctx.canvas.height = h;
    
    this.ctx.beginPath()
    
    if (this.type == "fullGrid") {
      for (let x = 0; x <= w; x += this.distance) {
        this.ctx.strokeStyle = "yellow"
        this.ctx.moveTo(x, 0);
        this.ctx.lineTo(x, h);
        this.ctx.fillStyle = "gray"
        this.ctx.font = "Arial 1px"
        this.ctx.fillText(`${x}`, x, 10)
        
        for (let y = 0; y <= h; y += this.distance) {
          this.ctx.strokeStyle = "yellow"
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(w, y);
          this.ctx.fillStyle = "gray"
          this.ctx.font = "Arial 1px"
          this.ctx.fillText(`${y}`, 0, y)
        }
      }
    } else if (this.type == "xGrid") {
      for (let x = 0; x <= w; x += this.distance) {
        this.ctx.moveTo(x, 0);
        this.ctx.lineTo(x, h);
        this.ctx.fillStyle = "gray"
        this.ctx.font = "Arial 1px"
        this.ctx.fillText(`${x}`, x, 10)
      }
    } else if (this.type == "yGrid") {
      for (let y = 0; y <= h; y += this.distance) {
        this.ctx.moveTo(0, y);
        this.ctx.lineTo(w, y);
        this.ctx.fillStyle = "gray"
        this.ctx.font = "Arial 1px"
        this.ctx.fillText(`${y}`, 0, y)
      }
    }else{
      console.warn("(2d-gam) the type isnot correct {fullGrid,xGrid,yGrid}")
    }
    callBackFunction(this.ctx)
    this.ctx.closePath()
    this.ctx.fill()
    this.ctx.stroke();
  }
}
 class Ellipse {
  constructor({
    radius = [60,30],
    position = {
      x: 100,
      y: 100
    },
    velocity = {
      x: 0,
      y: 0
    },
    rotation = 0,
    startAngle = 0,
    endAngle = Math.PI * 2,
    antiClockWise = false
  }) {
    this.radius = radius
    this.width = radius[0]
    this.height = radius[1]
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
    this.position = position
    this.velocity = velocity
    this.rotation = rotation
    this.startAngle = startAngle
    this.EndAngle = endAngle
    this.antiClockWise = antiClockWise
  }

  draw(c, callBackFunction = function() {}) {
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }
    
    c.beginPath()
    let ellipse = new Path2D()
    ellipse.ellipse(this.position.x,this.position.y
    ,this.width,this.height,this.rotation,this.startAngle,this.EndAngle,this.antiClockWise)
    c.strokeStyle = "black"
    c.fillStyle = "transparent"
    callBackFunction(c)
    c.fill(ellipse)
    c.stroke(ellipse)
    c.beginPath()
    
    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = ellipse
  }

  update(callbackFunction) {
    callbackFunction({
      r:this.radius,
      rX:this.width,
      rY:this.height,
      pos:this.position,
      vel:this.velocity,
      startAngle:this.startAngle,
      rotation:this.rotation,
      EndAngle:this.EndAngle
    })
  }
}
 class semiEllipseDown {
  constructor({
    radius = [60,30],
    position = {
      x: 100,
      y: 100
    },
    velocity = {
      x: 0,
      y: 0
    },
    rotation = 0
  }) {
    this.radius = radius
    this.width = radius[0]
    this.height = radius[1]
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
    this.position = position
    this.velocity = velocity
    this.rotation = rotation
  }

  draw(c, callBackFunction = function() {}) {
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }
    
    c.beginPath()
    let ellipse = new Path2D()
    ellipse.ellipse(this.position.x,this.position.y
    ,this.width,this.height,this.rotation,0,Math.PI,false)
    c.strokeStyle = "black"
    c.fillStyle = "transparent"
    callBackFunction(c)
    c.fill(ellipse)
    c.stroke(ellipse)
    c.beginPath()
    
    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = ellipse
  }

  update(callbackFunction) {
    callbackFunction({
      r:this.radius,
      rX:this.width,
      rY:this.height,
      pos:this.position,
      vel:this.velocity
    })
  }
}
 class semiEllipseUp {
  constructor({
    radius = [60,30],
    position = {
      x: 100,
      y: 100
    },
    velocity = {
      x: 0,
      y: 0
    },
    rotation = 0
  }) {
    this.radius = radius
    this.width = radius[0]
    this.height = radius[1]
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
    this.position = position
    this.velocity = velocity
    this.rotation = rotation
  }

  draw(c, callBackFunction = function() {}) {
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }
    
    c.beginPath()
    let ellipse = new Path2D()
    ellipse.ellipse(this.position.x,this.position.y
    ,this.width,this.height,this.rotation,0,Math.PI ,true)
    c.strokeStyle = "black"
    c.fillStyle = "transparent"
    callBackFunction(c)
    c.fill(ellipse)
    c.stroke(ellipse)
    c.beginPath()
    
    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = ellipse
  }

  update(callbackFunction) {
    callbackFunction({
      r:this.radius,
      rX:this.width,
      rY:this.height,
      pos:this.position,
      vel:this.velocity
    })
  }
}
 class Circle {
  constructor({
    radius,
    position = {
      x: 0,
      y: 0
    },
    velocity = {
      x: 0,
      y: 0
    },
    startAngle = 0,
    endAngle = Math.PI * 2,
    antiClockWise = false
  }) {
    //required values
    let width = radius
    if (width == "" ||
      width == undefined ||
      width == null) {
      throw new Error("(2d-gam) radius is required")
    } else if (typeof(width) !== "number") {
      throw new TypeError("(2d-gam) radius value must be a number")
    }
    this.radius = radius
    this.width = this.radius * 2
    this.position = position
    this.velocity = velocity
    this.height = this.radius * 2
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
    this.startAngle = startAngle
    this.EndAngle = endAngle
    this.antiClockWise = antiClockWise
  }
  draw(c, callBackFunction = function() {}) {
    //required value
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam)first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }

    //darwing the circle
    let circle = new Path2D()
    c.beginPath()
    circle.arc(this.position.x, this.position.y, this.radius,this.startAngle, this.EndAngle, false)
    c.fillStyle = "transparent"
    c.strokeStyle = "black"
    callBackFunction(c)
    c.stroke(circle)
    c.fill(circle)
    c.beginPath()
    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = circle
  }

  update(callbackFunction) {
    callbackFunction({ r: this.width, pos: this.position, vel: this.velocity })
  }
}
 class semiCircleDown {
  constructor({
    radius,
    position = {
      x: 0,
      y: 0
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    //required values
    let width = radius
    if (width == "" ||
      width == undefined ||
      width == null) {
      throw new Error("(2d-gam) radius is required")
    } else if (typeof(width) !== "number") {
      throw new TypeError("(2d-gam) radius value must be a number")
    }
    this.radius = radius
    this.width = this.radius * 2
    this.position = position
    this.velocity = velocity
    this.height = this.radius * 2
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
  }
  draw(c, callBackFunction = function() {}) {
    //required value
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }

    //darwing the circle
    let circledown = new Path2D()
    c.beginPath()
    circledown.arc(this.position.x, this.position.y, this.radius, 0, Math.PI, false)
    c.fillStyle = "transparent"
    c.strokeStyle = "black"
    callBackFunction(c)
    c.stroke(circledown)
    c.fill(circledown)
    c.beginPath()
    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = circledown
  }

  update(callbackFunction) {
    callbackFunction({ r: this.width, pos: this.position, vel: this.velocity })
  }
}
 class semiCircleUp {
  constructor({
    radius,
    position = {
      x: 0,
      y: 0
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    //required values
    let width = radius
    if (width == "" ||
      width == undefined ||
      width == null) {
      throw new Error("(2d-gam) radius is required")
    } else if (typeof(width) !== "number") {
      throw new TypeError("(2d-gam) radius value must be a number")
    }
    this.radius = radius
    this.width = this.radius * 2
    this.position = position
    this.velocity = velocity
    this.height = this.radius * 2
    this.create = false
    this.fillcolor = ""
    this.path = ""
    this.strokecolor = ""
  }
  draw(c, callBackFunction = function() {}) {
    //required value
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }

    //darwing the circle
    let circleUp = new Path2D()
    c.beginPath()
    circleUp.arc(this.position.x, this.position.y, this.radius, 0, Math.PI, true)
    c.fillStyle = "transparent"
    c.strokeStyle = "black"
    callBackFunction(c)
    c.stroke(circleUp)
    c.fill(circleUp)
    c.beginPath()

    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = circleUp
  }

  update(callbackFunction) {
    callbackFunction({ r: this.radius, pos: this.position, vel: this.velocity, w: this.width, h: this.height })
  }
}
 class Diamond {
  constructor({
    length = 40,
    position = {
      x: 40,
      y: 100
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    this.position = position
    this.length = length
    this.velocity = velocity
    this.width = this.length
    this.height = this.length * 1.5
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
  }
  draw(c, callBackFunction = function() {}) {
    //required value
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }

    //darwing the diamond
    let diamond = new Path2D()
    c.beginPath()
    diamond.moveTo(this.position.x, this.position.y)
    diamond.lineTo(this.position.x - 40, this.position.y - this.length)
    diamond.lineTo(this.position.x - 80, this.position.y)
    diamond.lineTo(this.position.x - 40, this.position.y + this.length)
    diamond.lineTo(this.position.x, this.position.y)
    c.fillStyle = "transparent"
    c.strokeStyle = "transparent"

    callBackFunction(c, this.position)
    c.stroke(diamond)
    c.fill(diamond)
    c.beginPath()

    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = diamond
  }

  update(callbackFunction) {
    callbackFunction({ pos: this.position, l: this.length, vel: this.velocity })
  }

  isCreated() {
    if (this.create) {
      return true
    } else {
      return false
    }
  }
}
 class HexagonShape {
  constructor({
    length = [40, 40, 40, 40, 40, 40],
    position = {
      x: 140,
      y: 140
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    this.length = length
    this.position = position
    this.velocity = velocity
    this.width = GreateX(this.length)
    this.height = GreateY(this.length)
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
  }
  draw(c, callBackFunction = function() {}) {
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }
    
    let x = this.position.x
    let y = this.position.y
    let HexagonShape = new Path2D()
    c.beginPath()
    HexagonShape.moveTo(this.position.x, this.position.y)
    HexagonShape.lineTo(x +this.length[0],y)
    HexagonShape.lineTo(x + this.length[0] + 20,y - this.length[1])
    HexagonShape.lineTo(x + this.length[0] , (y - this.length[1]) - this.length[2])
    HexagonShape.lineTo((x + this.length[0]) - this.length[3], (y - this.length[1]) - this.length[2])
    HexagonShape.lineTo(((x + this.length[0]) - this.length[3])-20,((y - this.length[1]) - this.length[2]) + this.length[4])
    HexagonShape.lineTo(((x + this.length[0]) - this.length[3]),(((y - this.length[1]) - this.length[2]) + this.length[4]) + this.length[5])
    
    c.fillStyle = "transparent"
    c.strokeStyle = "black"
    callBackFunction(c)
    c.fill(HexagonShape)
    c.stroke(HexagonShape)
    c.beginPath()
    
    this.create =true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = HexagonShape
  }

  update(callbackFunction = function() {}) {
    callbackFunction({
      w: this.width,
      h: this.height,
      pos: this.position,
      vel: this.velocity,
      l: this.length,
      s1: this.length[0],
      s2: this.length[1],
      s3: this.length[2],
      s4: this.length[3],
      s5: this.length[4],
      s6: this.length[5]
    })
  }
}
 class Parallelogram {
  constructor({
    length = [10,40],
    position = {
      x: 140,
      y: 140
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    this.length = length
    this.position = position
    this.velocity = velocity
    this.width = this.length[0]
    this.height = this.length[1]
    this.create =false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
  }

  draw(c, callBackFunction = function() {}) {
    //required value
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }

    //darwing the parallelogramm
    let parallelogramm = new Path2D()
    c.beginPath()
    parallelogramm.moveTo(this.position.x,this.position.y)
    parallelogramm.lineTo(this.position.x + this.length[0],this.position.y)
    parallelogramm.lineTo(this.position.x + this.length[0]+30,this.position.y - this.length[1])
    parallelogramm.lineTo((this.position.x + this.length[0] + 30) - this.length[0] , this.position.y - this.length[1])
    parallelogramm.lineTo(this.position.x,this.position.y)
    c.strokeStyle = "black"
    c.fillStyle = "transparent"
    callBackFunction(c)
    c.stroke(parallelogramm)
    c.fill(parallelogramm)
    c.beginPath()
    
    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = parallelogramm
  }

  update(callbackFunction) {
    callbackFunction({
      pos: this.position,
      vel: this.velocity,
      l: this.length,
      w:this.width,
      h:this.height
    })
  }
}
 class quadrilateralShape {
  constructor({
    length = [40, 40, 40, 40],
    position = {
      x: 140,
      y: 140
    },
    velocity = {
      x: 0,
      y: 0
    }
  }) {
    this.length = length
    this.position = position
    this.velocity = velocity
    this.width = GreateX(this.length)
    this.height = GreateY(this.length)
    this.create = false
    this.fillcolor = ""
    this.strokecolor = ""
    this.path = ""
  }
  draw(c, callBackFunction = function() {}) {
    if (c == "" ||
      c == undefined ||
      c == null) {
      throw new Error("(2d-gam) first argument is required")
    } else if (typeof(c) !== "object") {
      throw new TypeError("(2d-gam) the first value must be a canvas context")
    }
    //checking the type of the second argu
    if (typeof(callBackFunction) !== "function") {
      throw new TypeError("(2d-gam) the second argument must be a function")
    }
    
    let quadrilateralShape  = new Path2D()
    c.beginPath()
    quadrilateralShape.moveTo(this.position.x, this.position.y)
    quadrilateralShape.lineTo(this.position.x + this.length[0], this.position.y)
    quadrilateralShape.lineTo(this.position.x + this.length[0], this.position.y - this.length[1])

    quadrilateralShape.lineTo((this.position.x + this.length[0]) - this.length[2], this.position.y - this.length[0])
    quadrilateralShape.lineTo(this.position.x, (this.position.y - this.length[2]) + this.length[3])
    c.fillStyle = "transparent"
    c.strokeStyle = "black"
    callBackFunction(c)
    c.fill(quadrilateralShape)
    c.stroke(quadrilateralShape)
    c.beginPath()
    
    this.create = true
    this.fillcolor = c.fillStyle
    this.strokecolor = c.strokeStyle
    this.path = quadrilateralShape
  }

  update(callbackFunction = function() {}) {
    callbackFunction({ w: this.width, h: this.height, pos: this.position, vel: this.velocity, l: this.length, s1: this.length[0] , s2:this.length[1],s3:this.length[2],s4:this.length[3]})
  }
}


function exportAllClasses(){
  window.gam = {
  ResponsiveCanvas,
  Canvas,
  Circle,
  semiCircleUp,
  semiCircleDown,
  Square,
  Triangle,
  Parallelogram,
  Diamond,
  Snowflake,
  quadrilateralShape,
  HexagonShape,
  Ellipse,
  semiEllipseDown,
  semiEllipseUp,
  Grid,
  Event,
  Text,
  Detect,
  Move,
  Circular
  }
}

exportAllClasses()
